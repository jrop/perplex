<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/lexer.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/jrop/perplex" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/lexer.js~Lexer.html">Lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/token.js~EOFToken.html">EOFToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/token.js~Token.html">Token</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Position">Position</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TokenPosition">TokenPosition</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/lexer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import LexerState from &apos;./lexer-state&apos;;
import Token, { EOF } from &apos;./token&apos;;
import TokenTypes from &apos;./token-types&apos;;
/**
 * @typedef {{
 *   line: number,
 *   column: number,
 * }} Position
 */
/**
 * Lexes a source-string into tokens.
 *
 * @example
 * const lex = perplex(&apos;...&apos;)
 *   .token(&apos;ID&apos;, /my-id-regex/)
 *   .token(&apos;(&apos;, /\(/)
 *   .token(&apos;)&apos;, /\)/)
 *   .token(&apos;WS&apos;, /\s+/, true) // true means &apos;skip&apos;
 *
 * while ((let t = lex.next()).type != &apos;EOF&apos;) {
 *   console.log(t)
 * }
 * // alternatively:
 * console.log(lex.toArray())
 */
class Lexer {
    /* tslint:enable */
    /**
     * Creates a new Lexer instance
     * @param {string} [source = &apos;&apos;] The source string to operate on.
     */
    constructor(source = &apos;&apos;) {
        this._state = new LexerState(source);
        this._tokenTypes = new TokenTypes();
    }
    //
    // Getters/Setters
    //
    /**
     * Gets the current lexer position
     * @return {number} Returns the position
     */
    get position() {
        return this._state.position;
    }
    /**
     * Sets the current lexer position
     * @param {number} i The position to move to
     */
    set position(i) {
        this._state.position = i;
    }
    /**
     * Gets the source the lexer is operating on
     * @return {string} Returns the source
     */
    get source() {
        return this._state.source;
    }
    /**
     * Sets the source the lexer is operating on
     * @param {string} s The source to set
     */
    set source(s) {
        this._state = new LexerState(s);
    }
    //
    // METHODS
    //
    /**
     * Attaches this lexer to another lexer&apos;s state
     * @param {Lexer&lt;T&gt;} other The other lexer to attach to
     */
    attachTo(other) {
        this._state = other._state;
    }
    /**
     * Disables a token type
     * @param {T} type The token type to disable
     * @return {Lexer&lt;T&gt;}
     */
    disable(type) {
        this._tokenTypes.disable(type);
        return this;
    }
    /**
     * Enables a token type
     * @param {T} type The token type to enalbe
     * @param {?boolean} [enabled=true] Whether to enable/disable the specified token type
     * @return {Lexer&lt;T&gt;}
     */
    enable(type, enabled) {
        this._tokenTypes.enable(type, enabled);
        return this;
    }
    /**
     * Like {@link next}, but throws an exception if the next token is
     * not of the required type.
     * @param {T} type The token type expected from {@link next}
     * @return {Token&lt;T&gt;} Returns the {@link Token} on success
     */
    expect(type) {
        const t = this.next();
        if (t.type != type) {
            const pos = t.strpos();
            throw new Error(&apos;Expected &apos; + type + (t ? &apos;, got &apos; + t.type : &apos;&apos;) + &apos; at &apos; + pos.start.line + &apos;:&apos; + pos.start.column);
        }
        return t;
    }
    /**
     * Consumes and returns the next {@link Token} in the source string.
     * If there are no more tokens, it returns a {@link Token} of type `$EOF`
     * @return {Token&lt;T&gt;}
     */
    next() {
        try {
            const t = this.peek();
            this._state.position = t.end;
            return t;
        }
        catch (e) {
            this._state.position = e.end;
            throw e;
        }
    }
    /**
     * Returns the next {@link Token} in the source string, but does
     * not consume it.
     * If there are no more tokens, it returns a {@link Token} of type `$EOF`
     * @param {number} [position=`this.position`] The position at which to start reading
     * @return {Token&lt;T&gt;}
     */
    peek(position = this._state.position) {
        const read = (i = position) =&gt; {
            if (i &gt;= this._state.source.length)
                return EOF(this);
            const n = this._tokenTypes.peek(this._state.source, i);
            return n
                ? (n.item.skip
                    ? read(i + n.result[0].length)
                    : new Token(n.item.type, n.result[0], n.result.map(x =&gt; x), i, i + n.result[0].length, this))
                : null;
        };
        const t = read();
        if (t)
            return t;
        // we did not find a match
        let unexpected = this._state.source.substring(position, position + 1);
        try {
            this.peek(position + 1);
        }
        catch (e) {
            unexpected += e.unexpected;
        }
        const { line, column } = this.strpos(position);
        const e = new Error(`Unexpected input: ${unexpected} at (${line}:${column})`);
        e.unexpected = unexpected;
        e.end = position + unexpected.length;
        throw e;
    }
    /**
     * Converts a string-index (relative to the source string) to a line and a column.
     * @param {number} i The index to compute
     * @return {Position}
     */
    strpos(i) {
        let lines = this._state.source.substring(0, i).split(/\r?\n/);
        if (!Array.isArray(lines))
            lines = [lines];
        const line = lines.length;
        const column = lines[lines.length - 1].length + 1;
        return { line, column };
    }
    /**
     * Converts the token stream to an array of Tokens
     * @return {Token&lt;T&gt;[]} The array of tokens (not including (EOF))
     */
    toArray() {
        const oldState = this._state.copy();
        this._state.position = 0;
        const tkns = [];
        let t;
        while (!(t = this.next()).isEof())
            tkns.push(t);
        this._state = oldState;
        return tkns;
    }
    /**
     * Creates a new token type
     * @param {T} type The token type
     * @param {string|RegExp} pattern The pattern to match
     * @param {?boolean} skip Whether this type of token should be skipped
     * @return {Lexer&lt;T&gt;}
     */
    token(type, pattern, skip) {
        this._tokenTypes.token(type, pattern, skip);
        return this;
    }
}
export default Lexer;
export { EOF, Token, TokenTypes, LexerState };
//# sourceMappingURL=lexer.js.map</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
